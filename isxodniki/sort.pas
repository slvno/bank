unit sort;  //Название модуля

interface //Начало интерфейсной части

uses   //Названия подлючаемых внешних модулей
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  StdCtrls, ComCtrls;

type TSrok=record   //Тип, характеризующий 1 срок хранения
  chislo,           //число месяцев хранения
  kol: integer;     //количество повторений этого срока хранения в отчетном
                    //периоде (в дипломной работе - 12 мес)
end;
                                  //Данный тип описывает
Type TSum_Srokov=array of TSrok;  //одну комбинацию сроков хранения, дающую
                                  //в сумме отчетный период (12 мес)
                                  //Типизированный динамический массив, т.е.
                                  //его окончание жестко не зафиксировано

                                  //Данный тип описывает
Type TSroki=array of TSum_Srokov; //набор всевозможных комбинаций сроков
                                  //хранения. Типизированный динамический
                                  //массив, элементом которого является
                                  //динамический массив заданный типом
                                  //TSum_Srokov.
var
  Sroki: TSroki; //Переменная динамический массив набор всевозможных комбинаций
                 //сроков хранения.

  dlina,             // размеры динамических массивов
  dlina1:integer;    //

  varianti: array of integer;  //Переменная динамический массив возможные
                               //варианты сроков хранения. В дипломной работе
                               //3,6,9,12

  //procedure sort( max:integer; osn_:TSum_Srokov); //Объявление процедуры
  //Поиск всех вариантов сроков хранения, которыми можно представить исходный срок
  //хранения (kol_mes).

  function sort1( osn_:TSum_Srokov):TSum_Srokov;  //Объявление функции
  //упорядочивония значений комбинаций сроков хранения. Из 1 - 2  3 - 1  1 - 6 полу-
  //чаем 1 - 8  3 - 1
  // 8 вложений по 1 месяцу + 1 вложение по 3 м.

  function sort2( osn_:TSroki):TSroki;  //Объявление функции упорядочивания,
                                  //удаление повторяющихся
                                  //одинаковых комбинаций сроков вложений, т.е
                                  //Например, из трех одинаковых комбинаций
                                  //сроков вложений(1 - 2  5 - 2) получаем
                                 //одну комбинацию срока вложения (1 - 2  5 - 2)

  function est_znachenie(zn:integer):boolean; //Объявление функции провери.
  //ф-я определяет имеется ли это колво месяцев хранения в массиве возможных
  //вариантов сроков хранения

  procedure poluchit_mes;//Процедура определяет возможные варианты сроков
  //вложений.

implementation  //Конец интерфейсной части, начало секции реализации

//Поиск всех вариантов сроков хранения которыми можно представить исходный срок
//хранения (kol_mes).
procedure Polucit_Variants;
var nulli: TSum_Srokov;
 i,j, kol_mes:integer;
 s:string;
begin
  dlina:=0;   //Вспомогательные переменные для определения длины динамических
  dlina1:=0;  //массивов
  nulli:= nil;//Пустой указатель
  Sroki:=nil; //массив вариантов сроков хранения

  kol_mes:=12;
//       |
//    Количество месяцев
//       |    Очищаем массив вариантов сроков хранения
//       |          |
  sort( kol_mes,  nulli);   //Поиск всех возможных вариантов

  for i:=0 to length(Sroki)-1 do  //Упорядочивоние из 1 - 2  3 - 1  1 - 6 полу-
    Sroki[i]:=sort1(Sroki[i]);    //чаем 1 - 8  3 - 1
                                  // 8 вложений по 1 месяцу + 1 вложение по 3 м.

  Sroki:=sort2(Sroki);            //Упорядочивание, удаление повторяющихся
                                  //одинаковых комбинаций сроков вложений, т.е
                                  //Например, из трех (1 - 2  5 - 2) получаем
                                  //одну комбинацию (1 - 2  5 - 2)

//Добавляем полседний элемент вложения
  if est_znachenie(kol_mes) then      //Проверяем имеется ли это колво месяцев
                                      //хранения в массиве вариантов сроков
                                      //хранения
    begin
      dlina1:=length(Sroki);          //Определяем размер массива
      setlength(Sroki,dlina1+1);      //увеличиваем размер массива на 1 элемент
                                      //по "вертикали"

      setlength(Sroki[dlina1],1);     //увеличиваем размер массива на 1 элемент
                                      //по "горизонтали"

      Sroki[dlina1][0].chislo:=kol_mes;//Добавляем количество месяцев
      Sroki[dlina1][0].kol:=1;         //Добавляем количество повторений месяца
    end;


//Итогом работы этой процедуры будет набор всех вариантов сроков хранения
//которыми можно представить исходный срок хранения (kol_mes).

//Тестирование этой процедуры проходило на 2 различных компьютерах под
//управлением 2 различных операционных систем:
//a) Процессор: AMD Athlon 900/Объем оперативной памяти (ОП): 128 Mb/Объем файла
//подкачки: 300 Mb/Операционная система Windows 2000
//b)  Процессор: Intel Pentium 150/Объем оперативной памяти: 16 Mb/Объем файла
//подкачки: 100 Mb/Операционная система Windows 95

//Тестирование этой процедуры показало:
//1. Скорость вычисления всех возможных вариантов вложения для исходного срока
//вложения равного 12 месяцев на машине "а" заняло 5 с, на машине "b" - 25 минут
//2. При незначительном объеме подкачиваемой физической памяти (64 mb) на
//компьютере "b" программа завершается с ошибкой.
//3. Необходимым объемом ОП для работы программы без обращения к файлу подкачки
//для этого исходного срока вложения является значение 64 Mb свободной ОП.
//4. Скорость вычисления всех вариантов для сроков хранения {3, 6, 9, 12),
//используемых в дипломной работе, - менее 1 с на компьютере "b".
  {
  RichEdit1.Lines.Clear;
  for i:=0 to length(Sroki)-1 do
    begin
      s:='* ';

      for j:=0 to length(Sroki[i])-1 do
        begin
          s:=s+'     '+inttostr(Sroki[i][j].chislo)+' - '+inttostr(Sroki[i][j].kol)+'    '
        end;
      s:=s+' * ';
      RichEdit1.Lines.Add(s);
    end;
   }
end;


procedure poluchit_mes;
begin
  varianti:=nil;
  setlength(varianti,4);
  varianti[0]:=3;
  varianti[1]:=6;
  varianti[2]:=9;
  varianti[3]:=12;
end;

//Определение функции провери. ф-я определяет имеется ли это кол-во месяцев
//хранения в массиве возможных вариантов сроков хранения
function est_znachenie(zn:integer):boolean;     //Резульрат true - истина, если
//срок хранения  заданный zn имеется в массиве возможных вариантов сроков
//хранения - variant.
var i:integer;    //Счетчик цикла
begin
  result:=false;  //срок хранения  заданный zn не имеется в массиве возможных
  //вариантов сроков хранения. По умолчанию - не входит.

  if assigned(varianti) then //Если указатель на область памяти не nil (nil -
  //пусто), т.е. проверка определен ли массив возможных вариантов сроков
  //хранения varianti, если определен то быполняется составной оператор
    begin
      for i:=0 to length(varianti)-1 do   //В цыкле от первого элемента массива
      //возможных вариантов сроков хранения varianti до последнего, его номер
      //определяется length(varianti)-1
        if zn=varianti[i] then  //Проверяем условие, входит ли срок хранения
        //заданный zn в массив возможных вариантов сроков хранения varianti, т.е
        //равен ли он его конкретному элементу varianti[i], i - переменная
          result:=true; //Если входит, то Результат функции положительный
    end;

end;

//Определение функции упорядочивания,  удаление повторяющихся одинаковых
//комбинаций сроков вложений, т.е Например, из трех одинаковых комбинаций
//сроков вложений(1 - 2  5 - 2) получаем одну комбинацию срока вложения
//(1 - 2  5 - 2). Результат работы функции - набор различных упорядоченных
//комбинаций возможных вариантов сроков хранения дающих в сумме срок хранения в
//отчетном периоде (в дипломной работе - 12 мес)
function sort2( osn_:TSroki):TSroki;
label 1, 2;         //Объявление меток для переходов
var J,              //Счетчики
    I,              //
    l               //
    :integer;
                    //Временный массив. Определяет
    osn:TSroki;     //набор различных упорядоченных комбинаций возможных
    //вариантов сроков хранения дающих в сумме срок хранения в отчетном периоде
    //(в дипломной работе - 12 мес)
    rez:boolean;    //Результат, оприделяющий является ли конкретная комбинация
    //возможных вариантов сроков хранения повторяющейся в исходном массиве
    //возможных вариантов сроков хранения - osn_:TSroki
begin
  result:=nil;   //Результат, набор различных упорядоченных комбинаций
  //возможных вариантов сроков хранения, присваиваем пустой набор. nil - нулевой
  //указатель
  osn:=osn_;  //Запоминаем исходный массив osn_ во временном массиве osn
  //Требуется для сравнения с исходным массивом

  for i:=0 to length(osn_)-1 do  //В цыкле от первого элемента временного мас-ва
      //различных комбинация возможных вариантов сроков хранения до последнего,
      //его номер определяется length(osn_)-1
    begin
      for j:= 0 to length(osn_)-1 do //В цыкле от первого элемента исходого
      //массива различных комбинация возможных вариантов сроков хранения до
      //последнего, его номер определяется length(osn_)-1
        begin
          if (i<>j) then  //Проверяем является ли проверяемый элемент
          //проверяющим т.е. что osn_[1] не равен osn_[1], если не равен, то
          //выполняется составной оператор
            begin
                if assigned(osn[j]) then  //Проверяем существование исходого
                //массива различных комбинация возможных вариантов сроков
                //хранения. Проверка делается путем сравнения с нулевым
                //указателем nil, результат true если указатель не нулевой
                  if length(osn_[i])=length(osn[j]) then  //Если размер
                  //проверяющего элемент osn_[i] совпадает с проверяемым
                  //элементом - osn[j], то выполняется составной оператор.
                  //Размер означает колличесво возможных комбинаций сроков
                  //хранения и количество их повторения. Т.е. osn[i] - массив
                  //описывающий одну комбинацию, дающую в сумме срок хранения в
                  //отчетном периоде (в дипломной работе - 12 мес). Например
                  //osn[j][l].chislo - число месяцев, osn[j][l].kol - количество
                 //повторений данного месяца, - один l-ый элемент массива osn[j]
                    begin
                      //Размер массива

                      rez:=true; // => Считаем, что массивы одинаковые

                      for l:= 0 to length(osn[i])-1 do //В цыкле от первого
                      //элемента комбинации возможных вариантов сроков хранения до
                      //последнего, его номер определяется length(osn_[i])-1.
                      //Проверяем все элемента комбинации возможных вариантов
                      //сроков хранения.
                        begin

                          //Если Исходный osn_[i][l] и Проверяемый элемент
                          //osn[j][l], описывающий одну комбинацию, дающую в
                          //сумме срок хранения в отчетном периоде, Совпадают,
                          //то Имеем повторяющийся элемент. Сравнение идет по
                          //количеству месяцев osn[j][l].chislo и osn[j][l].kol
                          //- количество повторений данного месяца.
                          if (osn[j][l].chislo=osn_[i][l].chislo) and
                          (osn[j][l].kol=osn_[i][l].kol) then
                          else
                            begin
                              rez:=false; //Если не совпадает, то запоминаем это
                              //Для чего используем переменную rez
                              goto 1;   //Выходим из цыкла проверки
                            end
                        end;
1:
                      if rez then  //Если имеется совпадение элементов,
                      //совпадающий элемент,описывающий одну комбинацию, дающую
                      //в сумме срок хранения в отчетном периоде, очищается. Для
                      //Этого ему присваивается нулевой указатель, т.к. массив
                      //osn[j] является динамическим.
                        osn[j]:=nil;
                    end; //Конец цикла проверки массива различных комбинация
                    //возможных вариантов сроков хранения
            end;

        end;
    end;
  //Итогом работы этой процедуры будет массив, в котором отсутствуют
  //повторяющиеся элементы

  //Сохраняем этот массив в результирующем массиве различных комбинация
  //возможных вариантов сроков хранения - result
  for i:=0 to length(osn_)-1 do //В цыкле от первого элемента временного мас-ва
  //различных комбинация возможных вариантов сроков хранения до последнего,
  //его номер определяется length(osn_)-1
    if assigned(osn[i]) then //Проверяем существование исходого
    //массива различных комбинация возможных вариантов сроков хранения. Проверка
    // делается путем сравнения с нулевым указателем nil, результат true если
    //указатель не нулевой Если есть варианты различных комбинация возможных
    //вариантов сроков хранения, то
      begin
        l:=length(result);            //Определяем размер массива
        setlength(result,l+1);        //увеличиваем размер массива на 1 элемент
                                      //по "вертикали"

        result[l]:= osn[i];         //Добавляем 1 элемент, комбинация возможных
                                    //вариантов сроков хранения
      end;

  osn:=nil;
end;


function sort1( osn_:TSum_Srokov):TSum_Srokov;
label 1, 2;       //Объявление меток для переходов
var J,            //Счетчики
    I,            //
    l             //
    :integer;

    osn:TSum_Srokov; //Временный массив. Определяет
    //комбинацию возможных
    //вариантов сроков хранения, дающих в сумме срок хранения в отчетном периоде
    //(в дипломной работе - 12 мес)

    test: TSrok; //Временный массив. Определяет
    //один вариант срока хранения
begin
  result:=nil; //Результат, одна комбинация
  //возможных вариантов сроков хранения, присваиваем пустой набор. nil - нулевой
  //указатель
  osn:=osn_; //Запоминаем исходный массив osn_ во временном массиве osn
  //Требуется для сравнения с исходным массивом


  for i:=0 to length(osn_)-1 do  //В цыкле от первого элемента временного мас-ва
      //комбинации возможных вариантов сроков хранения до последнего,
      //его номер определяется length(osn_)-1. Движение по строкам
    begin
      for j:= 0 to length(osn_)-1 do //В цыкле от первого элемента исходого
      //массива комбинации возможных вариантов сроков хранения до
      //последнего, его номер определяется length(osn_)-1. Движение по строкам
        begin
          //Проверяем является ли проверяемый элемент
          //проверяющим т.е. что osn_[1] не равен osn_[1], если не равен;
          //Если Исходный osn[i]  и Проверяемый элемент osn_[J], описывающий
          //один вариант, Совпадают, то Имеем повторяющийся элемент. Сравнение
          //идет по количеству месяцев osn[i].chislo и osn[i].kol - количество
          //повторений данного месяца.
          //Если условие выполняется, то выполняем составной оператор
          if (i<>j) and (osn[i].chislo=osn_[j].chislo) and (osn_[j].chislo<>0)
          then
            begin    //Обнуляем значения совпадающего элемента
              osn[i].kol:=osn[i].kol+osn_[j].kol; //Добавляем к колличеству
              //повторений исходного элемента число повторений совпадающего
              //элемента
              osn_[j].chislo:=0; //Обнуляем значения совпадающего элемента -
              //число месяцев
              osn_[j].kol:=0; //Колличество повторений
            end;
        end;
    end;
  //Результатом работы данной процедуры будет проверяемый массив комбинации
  //возможных вариантов сроков хранения, в котором отсутствуют повторяющиеся
  //элементы.

  //Синхронизируем два массива: исходный и проверяемый.
  for i:=0 to length(osn_)-1 do //В цыкле от первого элемента временного мас-ва
      //комбинации возможных вариантов сроков хранения до последнего,
      //его номер определяется length(osn_)-1. Движение по строкам
    if osn[i].chislo<>osn_[i].chislo then  //Если их значения не совпадают, то
    //Очищаем повторяющийся элемент в исходном не исправленном массиве. Этот
    //массив использовался для сравнения.
      begin
        osn[i].chislo:=0;    //Обнуляем значения совпадающего элемента -
                             //число месяцев
        osn[i].kol:=0;//Колличество повторений
      end;

  //Сохраняем этот массив в результирующем массиве комбинации
  //возможных вариантов сроков хранения - result
  for i:=0 to length(osn_)-1 do //В цыкле от первого элемента временного мас-ва
  //комбинации возможных вариантов сроков хранения до последнего,
  //его номер определяется length(osn_)-1
    if osn[i].chislo<>0 then  //Проверяем существование исходого
    //массива различных комбинация возможных вариантов сроков хранения. Проверка
    // делается путем сравнения с нулем, результат true если число месяцев
    //не ноль. Если есть варианты различных
    //вариантов сроков хранения, то
      begin
        l:=length(result);             //Определяем размер массива
        setlength(result,l+1);         //увеличиваем размер массива на 1 элемент
                                       //по "вертикали"
        result[l].chislo:= osn[i].chislo; //Добавляем 1 элемент 1 комбинации
        result[l].kol:= osn[i].kol;       //вариантов сроков хранения
      end;

   //Упорядочиваем результирующий массив варианта сроков хранения по возрастанию
   //значения срока хранения result[i].chislo
   for j:=0 to length(result)-1 do //В цыкле от первого элемента мас-ва
  //комбинации возможных вариантов сроков хранения до последнего,
  //его номер определяется length(result)-1
     for i:=0 to length(result)-2 do //В цыкле от первого элемента мас-ва
  //комбинации возможных вариантов сроков хранения до последнего минус один
  //элемент, его номер определяется length(result)-2
  //если число месяцев больше предыдущего варианта больше счисла месяцев
  //следующего, то меняем их местами.
       if result[i].chislo>result[i+1].chislo then
       begin
         test:=result[i+1];
         result[i+1]:=result[i];
         result[i]:=test;
       end;
  osn:=nil;
end;

//Поиск всех вариантов сроков хранения, которыми можно представить исходный срок
//хранения (kol_mes). Процедура вызывает сама себя рекурсивно.
//Процедура реализует алгоритм представления целого положительного числа
//различными комбинациями сумм положительных целых чисел, дающих в сумме
//исходный срок хранения (kol_mes). Набор простых чисел - дискретный.
//Принимает последний член - max суммы членов osn_:TSum_Srokov
procedure sort( max:integer; osn_:TSum_Srokov);
label 1, 2;
var L,
    B,
    K,                //Делитель
    I,                //счетчик
    P:integer;        //Остаток

                           //Динамические массивы
    osn, test:TSum_Srokov; //комбинация возможных
    //вариантов сроков хранения дающая в сумме срок хранения в отчетном периоде
    //(в дипломной работе - 12 мес).
begin
  osn:=osn_; //Запоминаем исходный массив osn_ во временном массиве osn

  //Выполняем проверку на окончание разложения целого числа. Для этого отнимаем
  // 1 от последнего члена суммы.
      l:=1;
      b:=max-l;
      if b>0 then     //Если результат не ноль, то выполняем разложение max
      //дальше
        begin
          //Если 1, то раскладывать дальше нечего сохраняем последнюю комбинацию
          if b=1 then
            begin
              dlina:=length(osn);     //Определяем размер массива
              setlength(osn,dlina+2); //увеличиваем размер массива на 2 элемента
              osn[dlina].chislo:=l;   // Добавление ко всем членам суммы
              osn[dlina].kol:=1;      // этого последнего элемента   - 1

              osn[dlina+1].chislo:=b; // Добавление ко всем членам суммы
              osn[dlina+1].kol:=1;    // этого последнего элемента   - 1

             dlina1:=length(Sroki);  //Определяем размер результирующего массива
              //комбинаций вариантов сроков хранения

              setlength(Sroki,dlina1+1);//Увеличиваем результирующий массив
              //комбинаций вариантов сроков хранения на 1 комбинацию

              if est_znachenie(b) then  //Проверяем, что 1 месяц входит в число
              //допустимых вариантов сроков хранения. Если входит, то Запоминаем
              //этоту комбинацию вариантов сроков хранения в результирующем
              //массиве Sroki.
                Sroki[dlina1]:=osn;

              osn:=nil; //Очищаем комбинацию вариантов сроков хранения
            end
            //Если остаток не 1, то восстанавливаем исходное, раскладываемое
            //число. И продолжаем его раскладывать дальше
          else
            begin
              b:=b+1;

              //Выполняем процедуру разложения. В цикле от 1 до частного от
              //деления на 2 исходного числа. Оприделяем различные варианты
              //разложения b на более простые числа
              for k:=1 to b div 2 do
                begin
                  //Если  k месяцев входит в число
                  //допустимых вариантов сроков хранения.
                  if est_znachenie(k) then
                  //Если входит, то
                  for i:= 1 to b do //В цыкле оприделяем возможные комбинации
                  //из 2 чисел, которыми может быть представлено число B
                    begin
                      p:=b-k*i; // Определяем остаток, т.е.  5-1*2=3
                      //3 - остаток, 1 - количество повторений, 2 - делитель.
                      //i - количество повторений делителя k
                      //Если  p месяцев входит в число
                      //допустимых вариантов сроков хранения.
                      if est_znachenie(p) then
                      //то раскладываем его далее, если Остаток > 0
                      //Если меньше цикл прекращается
                      if p>0 then
                        begin
                            begin
                              //Увеличиваем результирующий массив
                              //комбинаций вариантов сроков хранения на 1
                              //комбинацию k-месяцев, i - повторений месяца.
                              //Используем временный динамический массив test
                              test:=osn;  //Присваиваем множители переданные
                              //в процедуре при ее рекурсивном вызове.

                              dlina:=length(test);
                           setlength(test,dlina+2); //Увеличиваем результирующий
                              //массив комбинаций вариантов сроков хранения на
                              //2 комбинации сроков хранения: (K-месяцев,
                              //i- повторений) и (p-месяцев,
                              //1- повторение), где max=k*i+p - полученное в
                              //процедуру число. K - определенн в ходе
                              //одной итерации в цикле по переменной K
                              //;I,P - определенные в ходе
                              //одной итерации в цикле по переменной I

                              test[dlina].chislo:=k;  //Добавляем к элементу
                              test[dlina].kol:=i;     //массива колличество
                              //месяцев k и число их повторений i

                              test[dlina+1].chislo:=p; //Добавляем к элементу
                              test[dlina+1].kol:=1;    //массива колличество
                              //месяцев p и число их повторений 1

                              dlina1:=length(Sroki);      //Определяем размер
                              //массива
                              setlength(Sroki,dlina1+1);  //увеличиваем размер
                              //массива на 1 элемент

                              Sroki[dlina1]:=test; //Добавляем 1 элемент,
                              //комбинация возможных вариантов сроков хранения

                              //Определяем другие варианты разложения остатка p
                              //Удаляем остаток из суммы членов.

                              dlina:=length(test);    //Определяем размер
                              setlength(test,dlina-1);//уменьшаем размер

                              //Вызываем эту функцию рекурсивно для нахождения
                              //всех вариантов разложения числа p. В функцию
                              //передаются в виде динамического массива test
                              //предыдущие сомножители разложения числа
                              //max-p, где max - число, которое раскладываем в
                              //этой процедуре
                              sort( p, test);

                              test:=nil;  //Очищаем временный массив,
                              //присваеваем нулевой указатель.
                            end;
                        end
                      else
                        goto 1;
                    end;
1:            //Завершили 1 итерацию цикла по k

                end;

            end;

        end
      else
        goto 2;
2:

end;

end.
